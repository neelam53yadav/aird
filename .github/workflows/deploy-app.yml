name: Deploy Application

on:
  push:
    branches:
      - main
      - db-fixes
    paths:
      - 'backend/**'
      - 'ui/**'
      - 'infra/docker-compose.prod.yml'
      - 'infra/airflow/**'
      - '.github/workflows/deploy-app.yml'
  workflow_dispatch:

env:
  GCP_PROJECT_ID: project-f3c8a334-a3f2-4f66-a06
  GCP_ZONE: us-central1-c
  VM_NAME: primedata-beta

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: projects/890841479962/locations/global/workloadIdentityPools/github-pool/providers/github-provider
          service_account: github-actions@project-f3c8a334-a3f2-4f66-a06.iam.gserviceaccount.com
          create_credentials_file: true

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        # Note: Project is already set via CLOUDSDK_CORE_PROJECT environment variable
        # Skipping explicit project setting to avoid token refresh issues

      - name: Check/Create VM
        id: vm-check
        run: |
          # Check if VM exists
          VM_EXISTS=$(gcloud compute instances describe ${{ env.VM_NAME }} \
            --zone=${{ env.GCP_ZONE }} \
            --format="value(name)" 2>/dev/null || echo "")
          
          if [ -z "$VM_EXISTS" ]; then
            echo "::error::VM '${{ env.VM_NAME }}' does not exist!"
            echo ""
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo "ğŸ“‹ **ACTION REQUIRED: Create VM Before Deployment**"
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo ""
            echo "The VM '${{ env.VM_NAME }}' needs to be created first using Terraform."
            echo ""
            echo "**ğŸš€ Quick Fix (Recommended):**"
            echo ""
            echo "1. Go to: https://github.com/neelam53yadav/aird/actions/workflows/deploy-infra.yml"
            echo "   (If you don't see it, click 'All workflows' in the left sidebar)"
            echo ""
            echo "2. Click the 'Run workflow' dropdown button (top right)"
            echo ""
            echo "3. Configure:"
            echo "   - Branch: ${{ github.ref_name }}"
            echo "   - Action: apply"
            echo "   - Auto-approve: true (optional)"
            echo ""
            echo "4. Click 'Run workflow'"
            echo ""
            echo "5. Wait 2-3 minutes for VM creation, then re-run this workflow"
            echo ""
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            exit 1
          fi
          
          # Check VM status
          VM_STATUS=$(gcloud compute instances describe ${{ env.VM_NAME }} \
            --zone=${{ env.GCP_ZONE }} \
            --format="value(status)" 2>/dev/null || echo "")
          
          if [ "$VM_STATUS" != "RUNNING" ]; then
            echo "âš ï¸  VM exists but is not running (status: $VM_STATUS)"
            echo "Starting VM..."
            gcloud compute instances start ${{ env.VM_NAME }} \
              --zone=${{ env.GCP_ZONE }}
            
            echo "Waiting for VM to start (this may take 30-60 seconds)..."
            sleep 30
            
            # Wait for VM to be fully running
            for i in {1..10}; do
              CURRENT_STATUS=$(gcloud compute instances describe ${{ env.VM_NAME }} \
                --zone=${{ env.GCP_ZONE }} \
                --format="value(status)" 2>/dev/null || echo "")
              if [ "$CURRENT_STATUS" == "RUNNING" ]; then
                echo "âœ… VM is now running"
                break
              fi
              echo "Waiting for VM to start... (attempt $i/10)"
              sleep 10
            done
          else
            echo "âœ… VM is running"
          fi

      - name: Get VM IP
        id: get-vm-ip
        run: |
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "Retrieving VM IP address..."
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo ""
          
          VM_IP=""
          
          # Method 1: Try getting external IP via accessConfigs (most direct method)
          # Note: API uses accessConfigs (plural), not accessConfig
          echo "Method 1: Trying accessConfigs method..."
          VM_IP=$(gcloud compute instances describe ${{ env.VM_NAME }} \
            --zone=${{ env.GCP_ZONE }} \
            --project=${{ env.GCP_PROJECT_ID }} \
            --format="value(networkInterfaces[0].accessConfigs[0].natIP)" 2>&1 | grep -v "^$" | head -1)
          
          # Remove any error messages and check if we got an IP
          if echo "$VM_IP" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$'; then
            echo "âœ… Found IP via Method 1: $VM_IP"
          else
            VM_IP=""
            echo "Method 1 failed, trying Method 2..."
            
            # Method 2: Parse JSON output to find natIP
            VM_JSON=$(gcloud compute instances describe ${{ env.VM_NAME }} \
              --zone=${{ env.GCP_ZONE }} \
              --project=${{ env.GCP_PROJECT_ID }} \
              --format="json" 2>/dev/null)
            
            if [ -n "$VM_JSON" ]; then
              # Extract natIP from JSON using jq if available, otherwise use grep
              if command -v jq &> /dev/null; then
                VM_IP=$(echo "$VM_JSON" | jq -r '.networkInterfaces[0].accessConfigs[]? | select(.natIP != null) | .natIP' | head -1)
              else
                # Fallback to grep method
                VM_IP=$(echo "$VM_JSON" | grep -o '"natIP"[[:space:]]*:[[:space:]]*"[^"]*"' | head -1 | sed -E 's/.*"natIP"[[:space:]]*:[[:space:]]*"([^"]*)".*/\1/')
              fi
              
              if echo "$VM_IP" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$'; then
                echo "âœ… Found IP via Method 2: $VM_IP"
              else
                VM_IP=""
                echo "Method 2 failed, trying Method 3..."
              fi
            fi
          fi
          
          # Method 3: Try YAML format (sometimes more reliable)
          if [ -z "$VM_IP" ]; then
            VM_YAML=$(gcloud compute instances describe ${{ env.VM_NAME }} \
              --zone=${{ env.GCP_ZONE }} \
              --project=${{ env.GCP_PROJECT_ID }} \
              --format="yaml(networkInterfaces[0].accessConfigs)" 2>/dev/null)
            
            if [ -n "$VM_YAML" ]; then
              VM_IP=$(echo "$VM_YAML" | grep -A 10 "accessConfigs:" | grep "natIP:" | head -1 | awk '{print $2}' | tr -d '"' | tr -d "'")
              
              if echo "$VM_IP" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$'; then
                echo "âœ… Found IP via Method 3: $VM_IP"
              else
                VM_IP=""
              fi
            fi
          fi
          
          # Method 4: Last resort - try getting IP from networkInterfaces.accessConfigs list (handles different array structures)
          if [ -z "$VM_IP" ]; then
            echo "Method 3 failed, trying Method 4 (alternative accessConfig parsing)..."
            VM_IP=$(gcloud compute instances describe ${{ env.VM_NAME }} \
              --zone=${{ env.GCP_ZONE }} \
              --project=${{ env.GCP_PROJECT_ID }} \
              --format="get(networkInterfaces[0].accessConfigs[0].natIP)" 2>/dev/null | grep -E '^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$' || echo "")
            
            if [ -n "$VM_IP" ]; then
              echo "âœ… Found IP via Method 4: $VM_IP"
            fi
          fi
          
          # If we still don't have an IP, show detailed VM information for debugging
          if [ -z "$VM_IP" ]; then
            echo ""
            echo "âŒ Error: Could not retrieve VM external IP address after trying 4 methods."
            echo ""
            echo "VM Details:"
            VM_STATUS=$(gcloud compute instances describe ${{ env.VM_NAME }} \
              --zone=${{ env.GCP_ZONE }} \
              --project=${{ env.GCP_PROJECT_ID }} \
              --format="value(status)" 2>/dev/null || echo "Unknown")
            echo "  Status: $VM_STATUS"
            echo ""
            echo "Full Network Configuration (for debugging):"
            gcloud compute instances describe ${{ env.VM_NAME }} \
              --zone=${{ env.GCP_ZONE }} \
              --project=${{ env.GCP_PROJECT_ID }} \
              --format="yaml(networkInterfaces)" 2>/dev/null || echo "  Could not retrieve network configuration"
            echo ""
            echo "Attempting to list all network interfaces and access configs..."
            gcloud compute instances describe ${{ env.VM_NAME }} \
              --zone=${{ env.GCP_ZONE }} \
              --project=${{ env.GCP_PROJECT_ID }} \
              --format="json" | grep -A 20 "networkInterfaces" || echo "  Could not retrieve network details"
            echo ""
            echo "Please check the VM configuration in GCP Console:"
            echo "  https://console.cloud.google.com/compute/instancesDetail/zones/${{ env.GCP_ZONE }}/instances/${{ env.VM_NAME }}?project=${{ env.GCP_PROJECT_ID }}"
            exit 1
          fi
          
          echo ""
          echo "âœ… VM IP: $VM_IP"
          echo "vm_ip=$VM_IP" >> $GITHUB_OUTPUT

      - name: Setup SSH
        run: |
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "Setting up SSH authentication..."
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo ""
          
          # Validate required secrets
          if [ -z "${{ secrets.VM_USERNAME }}" ]; then
            echo "âŒ Error: VM_USERNAME secret is not set in GitHub repository secrets"
            echo ""
            echo "Please add VM_USERNAME to your repository secrets:"
            echo "1. Go to: Settings â†’ Secrets and variables â†’ Actions"
            echo "2. Click 'New repository secret'"
            echo "3. Name: VM_USERNAME"
            echo "4. Value: <your-vm-username> (e.g., 'ubuntu' for Ubuntu VMs)"
            exit 1
          fi
          
          if [ -z "${{ secrets.VM_SSH_KEY }}" ]; then
            echo "âŒ Error: VM_SSH_KEY secret is not set in GitHub repository secrets"
            echo ""
            echo "Please add VM_SSH_KEY to your repository secrets:"
            echo "1. Go to: Settings â†’ Secrets and variables â†’ Actions"
            echo "2. Click 'New repository secret'"
            echo "3. Name: VM_SSH_KEY"
            echo "4. Value: <your-ssh-private-key-content>"
            echo ""
            echo "To generate SSH key pair and add to VM:"
            echo "  ssh-keygen -t rsa -b 4096 -C 'github-actions' -f ~/.ssh/vm_key"
            echo "  ssh-copy-id -i ~/.ssh/vm_key.pub ${{ secrets.VM_USERNAME }}@${{ steps.get-vm-ip.outputs.vm_ip }}"
            echo "  # Then copy ~/.ssh/vm_key content as VM_SSH_KEY secret"
            exit 1
          fi
          
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          # Write SSH private key
          echo "${{ secrets.VM_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          
          # Verify key file was created properly
          if [ ! -s ~/.ssh/id_rsa ]; then
            echo "âŒ Error: SSH key file is empty or not created properly"
            exit 1
          fi
          
          # Add VM to known_hosts
          ssh-keyscan -H ${{ steps.get-vm-ip.outputs.vm_ip }} >> ~/.ssh/known_hosts 2>/dev/null
          chmod 644 ~/.ssh/known_hosts
          
          echo "âœ… SSH setup complete"
          echo "  Username: ${{ secrets.VM_USERNAME }}"
          echo "  VM IP: ${{ steps.get-vm-ip.outputs.vm_ip }}"
          echo ""

      - name: Detect changed files and determine which services to rebuild
        id: detect-changes
        run: |
          # Get the base commit (for push events, use the previous commit)
          if [ "${{ github.event_name }}" == "push" ]; then
            BASE_SHA="${{ github.event.before }}"
            HEAD_SHA="${{ github.sha }}"
          else
            # For workflow_dispatch or PR, compare with main branch
            BASE_SHA="origin/main"
            HEAD_SHA="HEAD"
          fi
          
          # Fetch base commit if needed
          git fetch --depth=1 origin main 2>/dev/null || true
          
          # Get list of changed files
          CHANGED_FILES=$(git diff --name-only ${BASE_SHA}..${HEAD_SHA} 2>/dev/null || git diff --name-only HEAD~1 HEAD 2>/dev/null || echo "")
          
          if [ -z "$CHANGED_FILES" ]; then
            echo "No changed files detected, will rebuild all services"
            echo "rebuild_backend=true" >> $GITHUB_OUTPUT
            echo "rebuild_frontend=true" >> $GITHUB_OUTPUT
            echo "rebuild_airflow=true" >> $GITHUB_OUTPUT
            echo "skip_build=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "Changed files:"
          echo "$CHANGED_FILES"
          
          # Check for backend changes
          BACKEND_CHANGED=false
          if echo "$CHANGED_FILES" | grep -qE "^backend/(src|Dockerfile|requirements|alembic)"; then
            BACKEND_CHANGED=true
            echo "Backend source files changed"
          fi
          
          # Check for frontend changes
          FRONTEND_CHANGED=false
          if echo "$CHANGED_FILES" | grep -qE "^ui/(app|lib|components|Dockerfile|package\.json|next\.config|tsconfig)"; then
            FRONTEND_CHANGED=true
            echo "Frontend source files changed"
          fi
          
          # Check for Airflow changes
          AIRFLOW_CHANGED=false
          if echo "$CHANGED_FILES" | grep -qE "^infra/airflow"; then
            AIRFLOW_CHANGED=true
            echo "Airflow files changed"
          fi
          
          # Check for docker-compose changes (affects all services)
          COMPOSE_CHANGED=false
          if echo "$CHANGED_FILES" | grep -qE "^infra/docker-compose\.prod\.yml"; then
            COMPOSE_CHANGED=true
            echo "Docker Compose config changed - will rebuild all services"
          fi
          
          # Determine which services to rebuild
          if [ "$COMPOSE_CHANGED" = true ]; then
            # If compose file changed, rebuild all
            REBUILD_BACKEND=true
            REBUILD_FRONTEND=true
            REBUILD_AIRFLOW=true
          else
            REBUILD_BACKEND=$BACKEND_CHANGED
            REBUILD_FRONTEND=$FRONTEND_CHANGED
            REBUILD_AIRFLOW=$AIRFLOW_CHANGED
          fi
          
          # Check if we should skip build entirely (only docs/unrelated files changed)
          SKIP_BUILD=false
          if [ "$REBUILD_BACKEND" = false ] && [ "$REBUILD_FRONTEND" = false ] && [ "$REBUILD_AIRFLOW" = false ]; then
            # Check if only unrelated files changed
            UNRELATED_ONLY=$(echo "$CHANGED_FILES" | grep -vE "^(backend|ui|infra)" || echo "")
            if [ -n "$UNRELATED_ONLY" ] && [ -z "$(echo "$CHANGED_FILES" | grep -E "^(backend|ui|infra)")" ]; then
              SKIP_BUILD=true
              echo "Only unrelated files changed - skipping build"
            fi
          fi
          
          # Set outputs
          echo "rebuild_backend=$REBUILD_BACKEND" >> $GITHUB_OUTPUT
          echo "rebuild_frontend=$REBUILD_FRONTEND" >> $GITHUB_OUTPUT
          echo "rebuild_airflow=$REBUILD_AIRFLOW" >> $GITHUB_OUTPUT
          echo "skip_build=$SKIP_BUILD" >> $GITHUB_OUTPUT
          
          echo ""
          echo "Build plan:"
          echo "  Backend: $REBUILD_BACKEND"
          echo "  Frontend: $REBUILD_FRONTEND"
          echo "  Airflow: $REBUILD_AIRFLOW"
          echo "  Skip build: $SKIP_BUILD"

      - name: Prepare VM directory
        id: prepare-vm-dir
        run: |
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "Preparing deployment directory on VM..."
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo ""
          
          # Try to create /opt/primedata with sudo (if user has sudo access)
          echo "Attempting to create /opt/primedata with proper permissions..."
          if ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no ${{ secrets.VM_USERNAME }}@${{ steps.get-vm-ip.outputs.vm_ip }} \
            "sudo mkdir -p /opt/primedata/data /opt/primedata/logs && \
             sudo chown -R ${{ secrets.VM_USERNAME }}:${{ secrets.VM_USERNAME }} /opt/primedata && \
             sudo chmod -R 755 /opt/primedata" 2>/dev/null; then
            echo "âœ… Successfully created /opt/primedata with sudo"
            echo "deploy_path=/opt/primedata" >> $GITHUB_OUTPUT
          else
            echo "âš ï¸  Could not create /opt/primedata (may need sudo access)"
            echo "Using user's home directory instead..."
            # Use home directory as fallback
            ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no ${{ secrets.VM_USERNAME }}@${{ steps.get-vm-ip.outputs.vm_ip }} \
              "mkdir -p ~/primedata/data ~/primedata/logs"
            echo "âœ… Created ~/primedata directory"
            echo "deploy_path=~/primedata" >> $GITHUB_OUTPUT
          fi

      - name: Copy files to VM
        run: |
          DEPLOY_PATH="${{ steps.prepare-vm-dir.outputs.deploy_path }}"
          echo "Copying files to: ${DEPLOY_PATH}"
          rsync -avz --exclude='.git' --exclude='node_modules' --exclude='venv' \
            -e "ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no" \
            ./ ${{ secrets.VM_USERNAME }}@${{ steps.get-vm-ip.outputs.vm_ip }}:${DEPLOY_PATH}/

      - name: Build Docker images on VM
        if: steps.detect-changes.outputs.skip_build != 'true'
        run: |
          DEPLOY_PATH="${{ steps.prepare-vm-dir.outputs.deploy_path }}"
          DEPLOY_PATH_EXPANDED=$(ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no ${{ secrets.VM_USERNAME }}@${{ steps.get-vm-ip.outputs.vm_ip }} "echo ${DEPLOY_PATH}")
          
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "Building Docker images on GCP VM..."
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo ""
          
          # Get version tag from commit SHA (short)
          IMAGE_VERSION="${GITHUB_SHA:0:7}"
          IMAGE_TAG="v${IMAGE_VERSION}"
          
          echo "Image version tag: ${IMAGE_TAG}"
          echo ""
          
          # Build images conditionally based on what changed
          REBUILD_BACKEND="${{ steps.detect-changes.outputs.rebuild_backend }}"
          REBUILD_FRONTEND="${{ steps.detect-changes.outputs.rebuild_frontend }}"
          REBUILD_AIRFLOW="${{ steps.detect-changes.outputs.rebuild_airflow }}"
          
          # Cleanup Docker resources on VM before building
          echo "Cleaning up Docker resources on VM before building..."
          ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no ${{ secrets.VM_USERNAME }}@${{ steps.get-vm-ip.outputs.vm_ip }} \
            "docker system prune -f || true && docker builder prune -af || true"
          echo ""
          
          # Build backend if needed
          if [ "$REBUILD_BACKEND" = "true" ]; then
            echo "Building backend image on VM..."
            ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no ${{ secrets.VM_USERNAME }}@${{ steps.get-vm-ip.outputs.vm_ip }} \
              "cd ${DEPLOY_PATH_EXPANDED} && \
               docker build -t infra-backend:latest -t infra-backend:${IMAGE_TAG} -f backend/Dockerfile backend/"
            echo "âœ… Backend image built"
          fi
          
          # Build frontend if needed
          if [ "$REBUILD_FRONTEND" = "true" ]; then
            echo "Building frontend image on VM..."
            ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no ${{ secrets.VM_USERNAME }}@${{ steps.get-vm-ip.outputs.vm_ip }} \
              "cd ${DEPLOY_PATH_EXPANDED} && \
               docker build -t infra-frontend:latest -t infra-frontend:${IMAGE_TAG} -f ui/Dockerfile ui/"
            echo "âœ… Frontend image built"
          fi
          
          # Build Airflow if needed
          if [ "$REBUILD_AIRFLOW" = "true" ]; then
            echo "Building Airflow images on VM..."
            ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no ${{ secrets.VM_USERNAME }}@${{ steps.get-vm-ip.outputs.vm_ip }} \
              "cd ${DEPLOY_PATH_EXPANDED} && \
               docker build -t infra-airflow-webserver:latest -t infra-airflow-webserver:${IMAGE_TAG} -f infra/airflow/Dockerfile infra/airflow/ && \
               docker tag infra-airflow-webserver:latest infra-airflow-scheduler:latest && \
               docker tag infra-airflow-webserver:${IMAGE_TAG} infra-airflow-scheduler:${IMAGE_TAG}"
            echo "âœ… Airflow images built"
          fi
          
          # Cleanup old/unused images on VM (keep last 3 versions)
          echo ""
          echo "Cleaning up old Docker images on VM..."
          ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no ${{ secrets.VM_USERNAME }}@${{ steps.get-vm-ip.outputs.vm_ip }} \
            "docker image prune -f || true"
          echo "âœ… Image cleanup complete"

      - name: Deploy on VM
        run: |
          DEPLOY_PATH="${{ steps.prepare-vm-dir.outputs.deploy_path }}"
          # Expand ~ to full path if needed (in case we used home directory fallback)
          DEPLOY_PATH_EXPANDED=$(ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no ${{ secrets.VM_USERNAME }}@${{ steps.get-vm-ip.outputs.vm_ip }} "echo ${DEPLOY_PATH}")
          
          cat > /tmp/deploy_script.sh << EOF
          set -e
          DEPLOY_DIR="${DEPLOY_PATH_EXPANDED}"
          cd \${DEPLOY_DIR}
          
          # Load environment variables
          if [ -f .env.production ]; then
            export $(cat .env.production | grep -v '^#' | xargs)
          fi
          
          # Ensure Docker network exists (idempotent)
          docker network create primedata-network 2>/dev/null || echo "Network already exists"
          
          # Images are already built on this VM
          # Just start services using the built images
          echo "Starting services with Docker images built on VM..."
          docker-compose -f infra/docker-compose.prod.yml up -d --remove-orphans
          
          sleep 10
          
          docker-compose -f infra/docker-compose.prod.yml exec -T backend \
            alembic upgrade head || echo "Migration failed or already up to date"
          
          docker-compose -f infra/docker-compose.prod.yml ps
          EOF
          
          scp -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no \
            /tmp/deploy_script.sh \
            ${{ secrets.VM_USERNAME }}@${{ steps.get-vm-ip.outputs.vm_ip }}:/tmp/deploy_script.sh
          
          ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no \
            ${{ secrets.VM_USERNAME }}@${{ steps.get-vm-ip.outputs.vm_ip }} \
            "bash /tmp/deploy_script.sh"

      - name: Health Check
        run: |
          sleep 5
          curl -f http://${{ steps.get-vm-ip.outputs.vm_ip }}:8000/health || echo "Health check failed"
          curl -f http://${{ steps.get-vm-ip.outputs.vm_ip }}:8080/health || echo "Airflow health check failed"


