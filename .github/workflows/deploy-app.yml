name: Deploy Application

on:
  push:
    branches:
      - main
      - db-fixes
    paths:
      - 'backend/**'
      - 'ui/**'
      - 'infra/docker-compose.prod.yml'
      - 'infra/airflow/**'
  workflow_dispatch:

env:
  GCP_PROJECT_ID: project-f3c8a334-a3f2-4f66-a06
  GCP_ZONE: us-central1-c
  VM_NAME: primedata-beta

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: projects/890841479962/locations/global/workloadIdentityPools/github-pool/providers/github-provider
          service_account: github-actions@project-f3c8a334-a3f2-4f66-a06.iam.gserviceaccount.com
          create_credentials_file: true

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        # Note: Project is already set via CLOUDSDK_CORE_PROJECT environment variable
        # Skipping explicit project setting to avoid token refresh issues

      - name: Check/Create VM
        id: vm-check
        run: |
          # Check if VM exists
          VM_EXISTS=$(gcloud compute instances describe ${{ env.VM_NAME }} \
            --zone=${{ env.GCP_ZONE }} \
            --format="value(name)" 2>/dev/null || echo "")
          
          if [ -z "$VM_EXISTS" ]; then
            echo "::error::VM '${{ env.VM_NAME }}' does not exist!"
            echo ""
            echo "ðŸ“‹ **Action Required:** Create the VM using Terraform"
            echo ""
            echo "**Option 1: Use GitHub Actions (Recommended)**"
            echo "ðŸ‘‰ Click this link to create the VM:"
            echo "   https://github.com/neelam53yadav/aird/actions/workflows/deploy-infra.yml"
            echo ""
            echo "   Then:"
            echo "   1. Click 'Run workflow' button"
            echo "   2. Select branch: ${{ github.ref_name }}"
            echo "   3. Choose action: 'apply'"
            echo "   4. Click 'Run workflow'"
            echo ""
            echo "**Option 2: Use GCP Console**"
            echo "   Create a Compute Engine VM named '${{ env.VM_NAME }}' in zone ${{ env.GCP_ZONE }}"
            echo ""
            echo "After the VM is created, re-run this workflow."
            exit 1
          fi
          
          # Check VM status
          VM_STATUS=$(gcloud compute instances describe ${{ env.VM_NAME }} \
            --zone=${{ env.GCP_ZONE }} \
            --format="value(status)" 2>/dev/null || echo "")
          
          if [ "$VM_STATUS" != "RUNNING" ]; then
            echo "âš ï¸  VM exists but is not running (status: $VM_STATUS)"
            echo "Starting VM..."
            gcloud compute instances start ${{ env.VM_NAME }} \
              --zone=${{ env.GCP_ZONE }}
            
            echo "Waiting for VM to start (this may take 30-60 seconds)..."
            sleep 30
            
            # Wait for VM to be fully running
            for i in {1..10}; do
              CURRENT_STATUS=$(gcloud compute instances describe ${{ env.VM_NAME }} \
                --zone=${{ env.GCP_ZONE }} \
                --format="value(status)" 2>/dev/null || echo "")
              if [ "$CURRENT_STATUS" == "RUNNING" ]; then
                echo "âœ… VM is now running"
                break
              fi
              echo "Waiting for VM to start... (attempt $i/10)"
              sleep 10
            done
          else
            echo "âœ… VM is running"
          fi

      - name: Get VM IP
        id: get-vm-ip
        run: |
          # Get VM IP
          VM_IP=$(gcloud compute instances describe ${{ env.VM_NAME }} \
            --zone=${{ env.GCP_ZONE }} \
            --format="value(networkInterfaces[0].accessConfig[0].natIP)" 2>/dev/null || echo "")
          
          if [ -z "$VM_IP" ]; then
            echo "âŒ Error: Could not get VM IP address."
            VM_STATUS=$(gcloud compute instances describe ${{ env.VM_NAME }} \
              --zone=${{ env.GCP_ZONE }} \
              --format="value(status)" 2>/dev/null || echo "")
            echo "VM Status: $VM_STATUS"
            echo "Please check the VM configuration in GCP Console."
            exit 1
          fi
          
          echo "vm_ip=$VM_IP" >> $GITHUB_OUTPUT
          echo "âœ… VM IP: $VM_IP"

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.VM_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ steps.get-vm-ip.outputs.vm_ip }} >> ~/.ssh/known_hosts

      - name: Detect changed files and determine which services to rebuild
        id: detect-changes
        run: |
          # Get the base commit (for push events, use the previous commit)
          if [ "${{ github.event_name }}" == "push" ]; then
            BASE_SHA="${{ github.event.before }}"
            HEAD_SHA="${{ github.sha }}"
          else
            # For workflow_dispatch or PR, compare with main branch
            BASE_SHA="origin/main"
            HEAD_SHA="HEAD"
          fi
          
          # Fetch base commit if needed
          git fetch --depth=1 origin main 2>/dev/null || true
          
          # Get list of changed files
          CHANGED_FILES=$(git diff --name-only ${BASE_SHA}..${HEAD_SHA} 2>/dev/null || git diff --name-only HEAD~1 HEAD 2>/dev/null || echo "")
          
          if [ -z "$CHANGED_FILES" ]; then
            echo "No changed files detected, will rebuild all services"
            echo "rebuild_backend=true" >> $GITHUB_OUTPUT
            echo "rebuild_frontend=true" >> $GITHUB_OUTPUT
            echo "rebuild_airflow=true" >> $GITHUB_OUTPUT
            echo "skip_build=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "Changed files:"
          echo "$CHANGED_FILES"
          
          # Check for backend changes
          BACKEND_CHANGED=false
          if echo "$CHANGED_FILES" | grep -qE "^backend/(src|Dockerfile|requirements|alembic)"; then
            BACKEND_CHANGED=true
            echo "Backend source files changed"
          fi
          
          # Check for frontend changes
          FRONTEND_CHANGED=false
          if echo "$CHANGED_FILES" | grep -qE "^ui/(app|lib|components|Dockerfile|package\.json|next\.config|tsconfig)"; then
            FRONTEND_CHANGED=true
            echo "Frontend source files changed"
          fi
          
          # Check for Airflow changes
          AIRFLOW_CHANGED=false
          if echo "$CHANGED_FILES" | grep -qE "^infra/airflow"; then
            AIRFLOW_CHANGED=true
            echo "Airflow files changed"
          fi
          
          # Check for docker-compose changes (affects all services)
          COMPOSE_CHANGED=false
          if echo "$CHANGED_FILES" | grep -qE "^infra/docker-compose\.prod\.yml"; then
            COMPOSE_CHANGED=true
            echo "Docker Compose config changed - will rebuild all services"
          fi
          
          # Determine which services to rebuild
          if [ "$COMPOSE_CHANGED" = true ]; then
            # If compose file changed, rebuild all
            REBUILD_BACKEND=true
            REBUILD_FRONTEND=true
            REBUILD_AIRFLOW=true
          else
            REBUILD_BACKEND=$BACKEND_CHANGED
            REBUILD_FRONTEND=$FRONTEND_CHANGED
            REBUILD_AIRFLOW=$AIRFLOW_CHANGED
          fi
          
          # Check if we should skip build entirely (only docs/unrelated files changed)
          SKIP_BUILD=false
          if [ "$REBUILD_BACKEND" = false ] && [ "$REBUILD_FRONTEND" = false ] && [ "$REBUILD_AIRFLOW" = false ]; then
            # Check if only unrelated files changed
            UNRELATED_ONLY=$(echo "$CHANGED_FILES" | grep -vE "^(backend|ui|infra)" || echo "")
            if [ -n "$UNRELATED_ONLY" ] && [ -z "$(echo "$CHANGED_FILES" | grep -E "^(backend|ui|infra)")" ]; then
              SKIP_BUILD=true
              echo "Only unrelated files changed - skipping build"
            fi
          fi
          
          # Set outputs
          echo "rebuild_backend=$REBUILD_BACKEND" >> $GITHUB_OUTPUT
          echo "rebuild_frontend=$REBUILD_FRONTEND" >> $GITHUB_OUTPUT
          echo "rebuild_airflow=$REBUILD_AIRFLOW" >> $GITHUB_OUTPUT
          echo "skip_build=$SKIP_BUILD" >> $GITHUB_OUTPUT
          
          echo ""
          echo "Build plan:"
          echo "  Backend: $REBUILD_BACKEND"
          echo "  Frontend: $REBUILD_FRONTEND"
          echo "  Airflow: $REBUILD_AIRFLOW"
          echo "  Skip build: $SKIP_BUILD"

      - name: Copy files to VM
        run: |
          rsync -avz --exclude='.git' --exclude='node_modules' --exclude='venv' \
            -e "ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no" \
            ./ ${{ secrets.VM_USERNAME }}@${{ steps.get-vm-ip.outputs.vm_ip }}:/opt/primedata/

      - name: Deploy on VM
        run: |
          cat > /tmp/deploy_script.sh << 'SCRIPT_EOF'
          set -e
          cd /opt/primedata
          
          # Load environment variables
          if [ -f .env.production ]; then
            export $(cat .env.production | grep -v '^#' | xargs)
          fi
          
          # Ensure Docker network exists (idempotent)
          docker network create primedata-network 2>/dev/null || echo "Network already exists"
          
          # Build strategy variables (passed as arguments)
          REBUILD_BACKEND="$1"
          REBUILD_FRONTEND="$2"
          REBUILD_AIRFLOW="$3"
          SKIP_BUILD="$4"
          
          echo "Build plan:"
          echo "  Backend: $REBUILD_BACKEND"
          echo "  Frontend: $REBUILD_FRONTEND"
          echo "  Airflow: $REBUILD_AIRFLOW"
          echo "  Skip build: $SKIP_BUILD"
          
          if [ "$SKIP_BUILD" = "true" ]; then
            echo "Skipping build - no relevant changes detected"
            docker-compose -f infra/docker-compose.prod.yml up -d --remove-orphans
          else
            # Build only services that changed
            if [ "$REBUILD_BACKEND" = "true" ]; then
              echo "Building backend..."
              docker-compose -f infra/docker-compose.prod.yml build backend || true
            fi
            
            if [ "$REBUILD_FRONTEND" = "true" ]; then
              echo "Building frontend..."
              docker-compose -f infra/docker-compose.prod.yml build frontend || true
            fi
            
            if [ "$REBUILD_AIRFLOW" = "true" ]; then
              echo "Building Airflow services..."
              docker-compose -f infra/docker-compose.prod.yml build airflow-webserver airflow-scheduler || true
            fi
            
            echo "Starting all services..."
            docker-compose -f infra/docker-compose.prod.yml up -d --remove-orphans
          fi
          
          sleep 10
          
          docker-compose -f infra/docker-compose.prod.yml exec -T backend \
            alembic upgrade head || echo "Migration failed or already up to date"
          
          docker-compose -f infra/docker-compose.prod.yml ps
          SCRIPT_EOF
          
          scp -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no \
            /tmp/deploy_script.sh \
            ${{ secrets.VM_USERNAME }}@${{ steps.get-vm-ip.outputs.vm_ip }}:/tmp/deploy_script.sh
          
          ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no \
            ${{ secrets.VM_USERNAME }}@${{ steps.get-vm-ip.outputs.vm_ip }} \
            "bash /tmp/deploy_script.sh \
            '${{ steps.detect-changes.outputs.rebuild_backend }}' \
            '${{ steps.detect-changes.outputs.rebuild_frontend }}' \
            '${{ steps.detect-changes.outputs.rebuild_airflow }}' \
            '${{ steps.detect-changes.outputs.skip_build }}'"

      - name: Health Check
        run: |
          sleep 5
          curl -f http://${{ steps.get-vm-ip.outputs.vm_ip }}:8000/health || echo "Health check failed"
          curl -f http://${{ steps.get-vm-ip.outputs.vm_ip }}:8080/health || echo "Airflow health check failed"

